function generarTablaLL1(e){e.removeLeftRecursion();const o=calcularFIRST(e),n=calcularFOLLOW(e,o),t={};for(let o of e.SimbNoTerm)t[o]={};for(let r=0;r<e.NumReglas;r++){const a=e.Reglas[r],l=a.NombSimb,i=FIRSTdeSecuencia(a.Lista,o),s=i.has("ε");for(let o of i)if("ε"!==o){const n=obtenerTokenDeTerminal(e,o);t[l][n]&&t[l][n]!==r&&console.warn(`Conflicto en LL(1): ${l}, token ${n}`),t[l][n]=r}if(s)for(let o of n[l]){const n=obtenerTokenDeTerminal(e,o,!0);t[l][n]&&t[l][n]!==r&&console.warn(`Conflicto en LL(1): ${l}, token ${n}`),t[l][n]=r}}return t}function calcularFIRST(e){const o={};for(let n of e.SimbNoTerm)o[n]=new Set;let n=!0;for(;n;){n=!1;for(let t=0;t<e.NumReglas;t++){const r=e.Reglas[t],a=r.NombSimb,l=r.Lista,i=o[a].size,s=FIRSTdeSecuencia(l,o);for(let e of s)o[a].add(e);o[a].size>i&&(n=!0)}}return o}function calcularFOLLOW(e,o){const n={};for(let o of e.SimbNoTerm)n[o]=new Set;n[e.Reglas[0].NombSimb].add("FIN");let t=!0;for(;t;){t=!1;for(let r=0;r<e.NumReglas;r++){const a=e.Reglas[r],l=a.NombSimb,i=a.Lista;for(let e=0;e<i.length;e++){const r=i[e];if(!r.EsTerminal){const a=i.slice(e+1),s=FIRSTdeSecuencia(a,o),c=n[r.NombSimb].size;for(let e of s)"ε"!==e&&n[r.NombSimb].add(e);if(s.has("ε")||0===a.length)for(let e of n[l])n[r.NombSimb].add(e);n[r.NombSimb].size>c&&(t=!0)}}}}return n}function FIRSTdeSecuencia(e,o){const n=new Set;if(0===e.length)return n.add("ε"),n;for(let t=0;t<e.length;t++){const r=e[t];if(r.EsTerminal){n.add(r.NombSimb);break}{const a=o[r.NombSimb];for(let e of a)n.add(e);if(!a.has("ε"))break;t===e.length-1&&n.add("ε")}}return n}function obtenerTokenDeTerminal(e,o,n=!1){return"ε"===o?"ε":"FIN"===o&&n?"FIN":void 0!==e.TerminalesTokens[o]?e.TerminalesTokens[o]:(console.warn(`No se encontró token asignado al terminal "${o}". Usando el lexema como llave.`),o)}export{generarTablaLL1};